{"ast":null,"code":"import { PureComponent } from 'react';\n\nfunction isInteger(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n\nfunction isRangeVisible(_ref) {\n  var lastRenderedStartIndex = _ref.lastRenderedStartIndex,\n      lastRenderedStopIndex = _ref.lastRenderedStopIndex,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\nfunction scanForUnloadedRanges(_ref) {\n  var isItemLoaded = _ref.isItemLoaded,\n      itemCount = _ref.itemCount,\n      minimumBatchSize = _ref.minimumBatchSize,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n  var unloadedRanges = [];\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n\n  for (var _index = startIndex; _index <= stopIndex; _index++) {\n    var loaded = isItemLoaded(_index);\n\n    if (!loaded) {\n      rangeStopIndex = _index;\n\n      if (rangeStartIndex === null) {\n        rangeStartIndex = _index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push([rangeStartIndex, rangeStopIndex]);\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  } // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n\n\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), itemCount - 1);\n\n    for (var _index2 = rangeStopIndex + 1; _index2 <= potentialStopIndex; _index2++) {\n      if (!isItemLoaded(_index2)) {\n        rangeStopIndex = _index2;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push([rangeStartIndex, rangeStopIndex]);\n  } // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n\n\n  if (unloadedRanges.length) {\n    var firstRange = unloadedRanges[0];\n\n    while (firstRange[1] - firstRange[0] + 1 < minimumBatchSize && firstRange[0] > 0) {\n      var _index3 = firstRange[0] - 1;\n\n      if (!isItemLoaded(_index3)) {\n        firstRange[0] = _index3;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar InfiniteLoader = function (_PureComponent) {\n  inherits(InfiniteLoader, _PureComponent);\n\n  function InfiniteLoader() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, InfiniteLoader);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = InfiniteLoader.__proto__ || Object.getPrototypeOf(InfiniteLoader)).call.apply(_ref, [this].concat(args))), _this), _this._lastRenderedStartIndex = -1, _this._lastRenderedStopIndex = -1, _this._memoizedUnloadedRanges = [], _this._onItemsRendered = function (_ref2) {\n      var visibleStartIndex = _ref2.visibleStartIndex,\n          visibleStopIndex = _ref2.visibleStopIndex;\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!isInteger(visibleStartIndex) || !isInteger(visibleStopIndex)) {\n          console.warn('Invalid onItemsRendered signature; please refer to InfiniteLoader documentation.');\n        }\n\n        if (typeof _this.props.loadMoreRows === 'function') {\n          console.warn('InfiniteLoader \"loadMoreRows\" prop has been renamed to \"loadMoreItems\".');\n        }\n      }\n\n      _this._lastRenderedStartIndex = visibleStartIndex;\n      _this._lastRenderedStopIndex = visibleStopIndex;\n\n      _this._ensureRowsLoaded(visibleStartIndex, visibleStopIndex);\n    }, _this._setRef = function (listRef) {\n      _this._listRef = listRef;\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(InfiniteLoader, [{\n    key: 'resetloadMoreItemsCache',\n    value: function resetloadMoreItemsCache() {\n      var autoReload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this._memoizedUnloadedRanges = [];\n\n      if (autoReload) {\n        this._ensureRowsLoaded(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this._listRef == null) {\n          console.warn('Invalid list ref; please refer to InfiniteLoader documentation.');\n        }\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var children = this.props.children;\n      return children({\n        onItemsRendered: this._onItemsRendered,\n        ref: this._setRef\n      });\n    }\n  }, {\n    key: '_ensureRowsLoaded',\n    value: function _ensureRowsLoaded(startIndex, stopIndex) {\n      var _props = this.props,\n          isItemLoaded = _props.isItemLoaded,\n          itemCount = _props.itemCount,\n          _props$minimumBatchSi = _props.minimumBatchSize,\n          minimumBatchSize = _props$minimumBatchSi === undefined ? 10 : _props$minimumBatchSi,\n          _props$threshold = _props.threshold,\n          threshold = _props$threshold === undefined ? 15 : _props$threshold;\n      var unloadedRanges = scanForUnloadedRanges({\n        isItemLoaded: isItemLoaded,\n        itemCount: itemCount,\n        minimumBatchSize: minimumBatchSize,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(itemCount - 1, stopIndex + threshold)\n      }); // Avoid calling load-rows unless range has changed.\n      // This shouldn't be strictly necsesary, but is maybe nice to do.\n\n      if (this._memoizedUnloadedRanges.length !== unloadedRanges.length || this._memoizedUnloadedRanges.some(function (_ref3, index) {\n        var _ref4 = slicedToArray(_ref3, 2),\n            startIndex = _ref4[0],\n            stopIndex = _ref4[1];\n\n        return unloadedRanges[index][0] !== startIndex || unloadedRanges[index][1] !== stopIndex;\n      })) {\n        this._memoizedUnloadedRanges = unloadedRanges;\n\n        this._loadUnloadedRanges(unloadedRanges);\n      }\n    }\n  }, {\n    key: '_loadUnloadedRanges',\n    value: function _loadUnloadedRanges(unloadedRanges) {\n      var _this2 = this; // loadMoreRows was renamed to loadMoreItems in v1.0.3; will be removed in v2.0\n\n\n      var loadMoreItems = this.props.loadMoreItems || this.props.loadMoreRows;\n      unloadedRanges.forEach(function (_ref5) {\n        var _ref6 = slicedToArray(_ref5, 2),\n            startIndex = _ref6[0],\n            stopIndex = _ref6[1];\n\n        var promise = loadMoreItems(startIndex, stopIndex);\n\n        if (promise != null) {\n          promise.then(function () {\n            // Refresh the visible rows if any of them have just been loaded.\n            // Otherwise they will remain in their unloaded visual state.\n            if (isRangeVisible({\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\n              startIndex: startIndex,\n              stopIndex: stopIndex\n            })) {\n              // Handle an unmount while promises are still in flight.\n              if (_this2._listRef == null) {\n                return;\n              } // Resize cached row sizes for VariableSizeList,\n              // otherwise just re-render the list.\n\n\n              if (typeof _this2._listRef.resetAfterIndex === 'function') {\n                _this2._listRef.resetAfterIndex(startIndex, true);\n              } else {\n                // HACK reset temporarily cached item styles to force PureComponent to re-render.\n                // This is pretty gross, but I'm okay with it for now.\n                // Don't judge me.\n                if (typeof _this2._listRef._getItemStyleCache === 'function') {\n                  _this2._listRef._getItemStyleCache(-1);\n                }\n\n                _this2._listRef.forceUpdate();\n              }\n            }\n          });\n        }\n      });\n    }\n  }]);\n  return InfiniteLoader;\n}(PureComponent);\n\nexport default InfiniteLoader;","map":{"version":3,"sources":["/home/victor_oliveira/Documents/Estudos/React/testevisto/node_modules/react-window-infinite-loader/dist/index.esm.js"],"names":["PureComponent","isInteger","value","isFinite","Math","floor","isRangeVisible","_ref","lastRenderedStartIndex","lastRenderedStopIndex","startIndex","stopIndex","scanForUnloadedRanges","isItemLoaded","itemCount","minimumBatchSize","unloadedRanges","rangeStartIndex","rangeStopIndex","_index","loaded","push","potentialStopIndex","min","max","_index2","length","firstRange","_index3","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","i","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","possibleConstructorReturn","self","call","ReferenceError","slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","err","Array","isArray","InfiniteLoader","_PureComponent","_temp","_this","_ret","_len","arguments","args","_key","getPrototypeOf","apply","concat","_lastRenderedStartIndex","_lastRenderedStopIndex","_memoizedUnloadedRanges","_onItemsRendered","_ref2","visibleStartIndex","visibleStopIndex","process","env","NODE_ENV","console","warn","loadMoreRows","_ensureRowsLoaded","_setRef","listRef","_listRef","resetloadMoreItemsCache","autoReload","componentDidMount","render","children","onItemsRendered","ref","_props","_props$minimumBatchSi","_props$threshold","threshold","some","_ref3","index","_ref4","_loadUnloadedRanges","_this2","loadMoreItems","forEach","_ref5","_ref6","promise","then","resetAfterIndex","_getItemStyleCache","forceUpdate"],"mappings":"AAAA,SAASA,aAAT,QAA8B,OAA9B;;AAEA,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACxB,SAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6BC,QAAQ,CAACD,KAAD,CAArC,IAAgDE,IAAI,CAACC,KAAL,CAAWH,KAAX,MAAsBA,KAA7E;AACD;;AAED,SAASI,cAAT,CAAwBC,IAAxB,EAA8B;AAC5B,MAAIC,sBAAsB,GAAGD,IAAI,CAACC,sBAAlC;AAAA,MACIC,qBAAqB,GAAGF,IAAI,CAACE,qBADjC;AAAA,MAEIC,UAAU,GAAGH,IAAI,CAACG,UAFtB;AAAA,MAGIC,SAAS,GAAGJ,IAAI,CAACI,SAHrB;AAKA,SAAO,EAAED,UAAU,GAAGD,qBAAb,IAAsCE,SAAS,GAAGH,sBAApD,CAAP;AACD;;AAED,SAASI,qBAAT,CAA+BL,IAA/B,EAAqC;AACnC,MAAIM,YAAY,GAAGN,IAAI,CAACM,YAAxB;AAAA,MACIC,SAAS,GAAGP,IAAI,CAACO,SADrB;AAAA,MAEIC,gBAAgB,GAAGR,IAAI,CAACQ,gBAF5B;AAAA,MAGIL,UAAU,GAAGH,IAAI,CAACG,UAHtB;AAAA,MAIIC,SAAS,GAAGJ,IAAI,CAACI,SAJrB;AAMA,MAAIK,cAAc,GAAG,EAArB;AAEA,MAAIC,eAAe,GAAG,IAAtB;AACA,MAAIC,cAAc,GAAG,IAArB;;AAEA,OAAK,IAAIC,MAAM,GAAGT,UAAlB,EAA8BS,MAAM,IAAIR,SAAxC,EAAmDQ,MAAM,EAAzD,EAA6D;AAC3D,QAAIC,MAAM,GAAGP,YAAY,CAACM,MAAD,CAAzB;;AAEA,QAAI,CAACC,MAAL,EAAa;AACXF,MAAAA,cAAc,GAAGC,MAAjB;;AACA,UAAIF,eAAe,KAAK,IAAxB,EAA8B;AAC5BA,QAAAA,eAAe,GAAGE,MAAlB;AACD;AACF,KALD,MAKO,IAAID,cAAc,KAAK,IAAvB,EAA6B;AAClCF,MAAAA,cAAc,CAACK,IAAf,CAAoB,CAACJ,eAAD,EAAkBC,cAAlB,CAApB;AAEAD,MAAAA,eAAe,GAAGC,cAAc,GAAG,IAAnC;AACD;AACF,GAzBkC,CA2BnC;AACA;;;AACA,MAAIA,cAAc,KAAK,IAAvB,EAA6B;AAC3B,QAAII,kBAAkB,GAAGlB,IAAI,CAACmB,GAAL,CAASnB,IAAI,CAACoB,GAAL,CAASN,cAAT,EAAyBD,eAAe,GAAGF,gBAAlB,GAAqC,CAA9D,CAAT,EAA2ED,SAAS,GAAG,CAAvF,CAAzB;;AAEA,SAAK,IAAIW,OAAO,GAAGP,cAAc,GAAG,CAApC,EAAuCO,OAAO,IAAIH,kBAAlD,EAAsEG,OAAO,EAA7E,EAAiF;AAC/E,UAAI,CAACZ,YAAY,CAACY,OAAD,CAAjB,EAA4B;AAC1BP,QAAAA,cAAc,GAAGO,OAAjB;AACD,OAFD,MAEO;AACL;AACD;AACF;;AAEDT,IAAAA,cAAc,CAACK,IAAf,CAAoB,CAACJ,eAAD,EAAkBC,cAAlB,CAApB;AACD,GAzCkC,CA2CnC;AACA;;;AACA,MAAIF,cAAc,CAACU,MAAnB,EAA2B;AACzB,QAAIC,UAAU,GAAGX,cAAc,CAAC,CAAD,CAA/B;;AAEA,WAAOW,UAAU,CAAC,CAAD,CAAV,GAAgBA,UAAU,CAAC,CAAD,CAA1B,GAAgC,CAAhC,GAAoCZ,gBAApC,IAAwDY,UAAU,CAAC,CAAD,CAAV,GAAgB,CAA/E,EAAkF;AAChF,UAAIC,OAAO,GAAGD,UAAU,CAAC,CAAD,CAAV,GAAgB,CAA9B;;AAEA,UAAI,CAACd,YAAY,CAACe,OAAD,CAAjB,EAA4B;AAC1BD,QAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBC,OAAhB;AACD,OAFD,MAEO;AACL;AACD;AACF;AACF;;AAED,SAAOZ,cAAP;AACD;;AAED,IAAIa,cAAc,GAAG,UAAUC,QAAV,EAAoBC,WAApB,EAAiC;AACpD,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AACtC,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AACD;AACF,CAJD;;AAMA,IAAIC,WAAW,GAAG,YAAY;AAC5B,WAASC,gBAAT,CAA0BC,MAA1B,EAAkCC,KAAlC,EAAyC;AACvC,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACV,MAA1B,EAAkCW,CAAC,EAAnC,EAAuC;AACrC,UAAIC,UAAU,GAAGF,KAAK,CAACC,CAAD,CAAtB;AACAC,MAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AACAD,MAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AACA,UAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAC3BC,MAAAA,MAAM,CAACC,cAAP,CAAsBR,MAAtB,EAA8BG,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AACD;AACF;;AAED,SAAO,UAAUP,WAAV,EAAuBc,UAAvB,EAAmCC,WAAnC,EAAgD;AACrD,QAAID,UAAJ,EAAgBX,gBAAgB,CAACH,WAAW,CAACgB,SAAb,EAAwBF,UAAxB,CAAhB;AAChB,QAAIC,WAAJ,EAAiBZ,gBAAgB,CAACH,WAAD,EAAce,WAAd,CAAhB;AACjB,WAAOf,WAAP;AACD,GAJD;AAKD,CAhBiB,EAAlB;;AAkBA,IAAIiB,QAAQ,GAAG,UAAUC,QAAV,EAAoBC,UAApB,EAAgC;AAC7C,MAAI,OAAOA,UAAP,KAAsB,UAAtB,IAAoCA,UAAU,KAAK,IAAvD,EAA6D;AAC3D,UAAM,IAAIlB,SAAJ,CAAc,6DAA6D,OAAOkB,UAAlF,CAAN;AACD;;AAEDD,EAAAA,QAAQ,CAACF,SAAT,GAAqBL,MAAM,CAACS,MAAP,CAAcD,UAAU,IAAIA,UAAU,CAACH,SAAvC,EAAkD;AACrEK,IAAAA,WAAW,EAAE;AACXlD,MAAAA,KAAK,EAAE+C,QADI;AAEXV,MAAAA,UAAU,EAAE,KAFD;AAGXE,MAAAA,QAAQ,EAAE,IAHC;AAIXD,MAAAA,YAAY,EAAE;AAJH;AADwD,GAAlD,CAArB;AAQA,MAAIU,UAAJ,EAAgBR,MAAM,CAACW,cAAP,GAAwBX,MAAM,CAACW,cAAP,CAAsBJ,QAAtB,EAAgCC,UAAhC,CAAxB,GAAsED,QAAQ,CAACK,SAAT,GAAqBJ,UAA3F;AACjB,CAdD;;AAgBA,IAAIK,yBAAyB,GAAG,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AACpD,MAAI,CAACD,IAAL,EAAW;AACT,UAAM,IAAIE,cAAJ,CAAmB,2DAAnB,CAAN;AACD;;AAED,SAAOD,IAAI,KAAK,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,UAAjD,CAAJ,GAAmEA,IAAnE,GAA0ED,IAAjF;AACD,CAND;;AAQA,IAAIG,aAAa,GAAG,YAAY;AAC9B,WAASC,aAAT,CAAuBC,GAAvB,EAA4BxB,CAA5B,EAA+B;AAC7B,QAAIyB,IAAI,GAAG,EAAX;AACA,QAAIC,EAAE,GAAG,IAAT;AACA,QAAIC,EAAE,GAAG,KAAT;AACA,QAAIC,EAAE,GAAGC,SAAT;;AAEA,QAAI;AACF,WAAK,IAAIC,EAAE,GAAGN,GAAG,CAACO,MAAM,CAACC,QAAR,CAAH,EAAT,EAAiCC,EAAtC,EAA0C,EAAEP,EAAE,GAAG,CAACO,EAAE,GAAGH,EAAE,CAACI,IAAH,EAAN,EAAiBC,IAAxB,CAA1C,EAAyET,EAAE,GAAG,IAA9E,EAAoF;AAClFD,QAAAA,IAAI,CAACzC,IAAL,CAAUiD,EAAE,CAACpE,KAAb;;AAEA,YAAImC,CAAC,IAAIyB,IAAI,CAACpC,MAAL,KAAgBW,CAAzB,EAA4B;AAC7B;AACF,KAND,CAME,OAAOoC,GAAP,EAAY;AACZT,MAAAA,EAAE,GAAG,IAAL;AACAC,MAAAA,EAAE,GAAGQ,GAAL;AACD,KATD,SASU;AACR,UAAI;AACF,YAAI,CAACV,EAAD,IAAOI,EAAE,CAAC,QAAD,CAAb,EAAyBA,EAAE,CAAC,QAAD,CAAF;AAC1B,OAFD,SAEU;AACR,YAAIH,EAAJ,EAAQ,MAAMC,EAAN;AACT;AACF;;AAED,WAAOH,IAAP;AACD;;AAED,SAAO,UAAUD,GAAV,EAAexB,CAAf,EAAkB;AACvB,QAAIqC,KAAK,CAACC,OAAN,CAAcd,GAAd,CAAJ,EAAwB;AACtB,aAAOA,GAAP;AACD,KAFD,MAEO,IAAIO,MAAM,CAACC,QAAP,IAAmB3B,MAAM,CAACmB,GAAD,CAA7B,EAAoC;AACzC,aAAOD,aAAa,CAACC,GAAD,EAAMxB,CAAN,CAApB;AACD,KAFM,MAEA;AACL,YAAM,IAAIL,SAAJ,CAAc,sDAAd,CAAN;AACD;AACF,GARD;AASD,CApCmB,EAApB;;AAsCA,IAAI4C,cAAc,GAAG,UAAUC,cAAV,EAA0B;AAC7C7B,EAAAA,QAAQ,CAAC4B,cAAD,EAAiBC,cAAjB,CAAR;;AAEA,WAASD,cAAT,GAA0B;AACxB,QAAIrE,IAAJ;;AAEA,QAAIuE,KAAJ,EAAWC,KAAX,EAAkBC,IAAlB;;AAEAnD,IAAAA,cAAc,CAAC,IAAD,EAAO+C,cAAP,CAAd;;AAEA,SAAK,IAAIK,IAAI,GAAGC,SAAS,CAACxD,MAArB,EAA6ByD,IAAI,GAAGT,KAAK,CAACO,IAAD,CAAzC,EAAiDG,IAAI,GAAG,CAA7D,EAAgEA,IAAI,GAAGH,IAAvE,EAA6EG,IAAI,EAAjF,EAAqF;AACnFD,MAAAA,IAAI,CAACC,IAAD,CAAJ,GAAaF,SAAS,CAACE,IAAD,CAAtB;AACD;;AAED,WAAOJ,IAAI,IAAIF,KAAK,IAAIC,KAAK,GAAGxB,yBAAyB,CAAC,IAAD,EAAO,CAAChD,IAAI,GAAGqE,cAAc,CAACtB,SAAf,IAA4BZ,MAAM,CAAC2C,cAAP,CAAsBT,cAAtB,CAApC,EAA2EnB,IAA3E,CAAgF6B,KAAhF,CAAsF/E,IAAtF,EAA4F,CAAC,IAAD,EAAOgF,MAAP,CAAcJ,IAAd,CAA5F,CAAP,CAAjC,EAA2JJ,KAA/J,CAAL,EAA4KA,KAAK,CAACS,uBAAN,GAAgC,CAAC,CAA7M,EAAgNT,KAAK,CAACU,sBAAN,GAA+B,CAAC,CAAhP,EAAmPV,KAAK,CAACW,uBAAN,GAAgC,EAAnR,EAAuRX,KAAK,CAACY,gBAAN,GAAyB,UAAUC,KAAV,EAAiB;AAC9U,UAAIC,iBAAiB,GAAGD,KAAK,CAACC,iBAA9B;AAAA,UACIC,gBAAgB,GAAGF,KAAK,CAACE,gBAD7B;;AAGA,UAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,YAAI,CAAChG,SAAS,CAAC4F,iBAAD,CAAV,IAAiC,CAAC5F,SAAS,CAAC6F,gBAAD,CAA/C,EAAmE;AACjEI,UAAAA,OAAO,CAACC,IAAR,CAAa,kFAAb;AACD;;AAED,YAAI,OAAOpB,KAAK,CAAC3C,KAAN,CAAYgE,YAAnB,KAAoC,UAAxC,EAAoD;AAClDF,UAAAA,OAAO,CAACC,IAAR,CAAa,yEAAb;AACD;AACF;;AAEDpB,MAAAA,KAAK,CAACS,uBAAN,GAAgCK,iBAAhC;AACAd,MAAAA,KAAK,CAACU,sBAAN,GAA+BK,gBAA/B;;AAEAf,MAAAA,KAAK,CAACsB,iBAAN,CAAwBR,iBAAxB,EAA2CC,gBAA3C;AACD,KAlBc,EAkBZf,KAAK,CAACuB,OAAN,GAAgB,UAAUC,OAAV,EAAmB;AACpCxB,MAAAA,KAAK,CAACyB,QAAN,GAAiBD,OAAjB;AACD,KApBc,EAoBZzB,KApBQ,CAAJ,EAoBIvB,yBAAyB,CAACwB,KAAD,EAAQC,IAAR,CApBpC;AAqBD;;AAED/C,EAAAA,WAAW,CAAC2C,cAAD,EAAiB,CAAC;AAC3BhC,IAAAA,GAAG,EAAE,yBADsB;AAE3B1C,IAAAA,KAAK,EAAE,SAASuG,uBAAT,GAAmC;AACxC,UAAIC,UAAU,GAAGxB,SAAS,CAACxD,MAAV,GAAmB,CAAnB,IAAwBwD,SAAS,CAAC,CAAD,CAAT,KAAiBhB,SAAzC,GAAqDgB,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAArF;AAEA,WAAKQ,uBAAL,GAA+B,EAA/B;;AAEA,UAAIgB,UAAJ,EAAgB;AACd,aAAKL,iBAAL,CAAuB,KAAKb,uBAA5B,EAAqD,KAAKC,sBAA1D;AACD;AACF;AAV0B,GAAD,EAWzB;AACD7C,IAAAA,GAAG,EAAE,mBADJ;AAED1C,IAAAA,KAAK,EAAE,SAASyG,iBAAT,GAA6B;AAClC,UAAIZ,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,YAAI,KAAKO,QAAL,IAAiB,IAArB,EAA2B;AACzBN,UAAAA,OAAO,CAACC,IAAR,CAAa,iEAAb;AACD;AACF;AACF;AARA,GAXyB,EAoBzB;AACDvD,IAAAA,GAAG,EAAE,QADJ;AAED1C,IAAAA,KAAK,EAAE,SAAS0G,MAAT,GAAkB;AACvB,UAAIC,QAAQ,GAAG,KAAKzE,KAAL,CAAWyE,QAA1B;AAGA,aAAOA,QAAQ,CAAC;AACdC,QAAAA,eAAe,EAAE,KAAKnB,gBADR;AAEdoB,QAAAA,GAAG,EAAE,KAAKT;AAFI,OAAD,CAAf;AAID;AAVA,GApByB,EA+BzB;AACD1D,IAAAA,GAAG,EAAE,mBADJ;AAED1C,IAAAA,KAAK,EAAE,SAASmG,iBAAT,CAA2B3F,UAA3B,EAAuCC,SAAvC,EAAkD;AACvD,UAAIqG,MAAM,GAAG,KAAK5E,KAAlB;AAAA,UACIvB,YAAY,GAAGmG,MAAM,CAACnG,YAD1B;AAAA,UAEIC,SAAS,GAAGkG,MAAM,CAAClG,SAFvB;AAAA,UAGImG,qBAAqB,GAAGD,MAAM,CAACjG,gBAHnC;AAAA,UAIIA,gBAAgB,GAAGkG,qBAAqB,KAAK/C,SAA1B,GAAsC,EAAtC,GAA2C+C,qBAJlE;AAAA,UAKIC,gBAAgB,GAAGF,MAAM,CAACG,SAL9B;AAAA,UAMIA,SAAS,GAAGD,gBAAgB,KAAKhD,SAArB,GAAiC,EAAjC,GAAsCgD,gBANtD;AASA,UAAIlG,cAAc,GAAGJ,qBAAqB,CAAC;AACzCC,QAAAA,YAAY,EAAEA,YAD2B;AAEzCC,QAAAA,SAAS,EAAEA,SAF8B;AAGzCC,QAAAA,gBAAgB,EAAEA,gBAHuB;AAIzCL,QAAAA,UAAU,EAAEN,IAAI,CAACoB,GAAL,CAAS,CAAT,EAAYd,UAAU,GAAGyG,SAAzB,CAJ6B;AAKzCxG,QAAAA,SAAS,EAAEP,IAAI,CAACmB,GAAL,CAAST,SAAS,GAAG,CAArB,EAAwBH,SAAS,GAAGwG,SAApC;AAL8B,OAAD,CAA1C,CAVuD,CAkBvD;AACA;;AACA,UAAI,KAAKzB,uBAAL,CAA6BhE,MAA7B,KAAwCV,cAAc,CAACU,MAAvD,IAAiE,KAAKgE,uBAAL,CAA6B0B,IAA7B,CAAkC,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AAC7H,YAAIC,KAAK,GAAG5D,aAAa,CAAC0D,KAAD,EAAQ,CAAR,CAAzB;AAAA,YACI3G,UAAU,GAAG6G,KAAK,CAAC,CAAD,CADtB;AAAA,YAEI5G,SAAS,GAAG4G,KAAK,CAAC,CAAD,CAFrB;;AAIA,eAAOvG,cAAc,CAACsG,KAAD,CAAd,CAAsB,CAAtB,MAA6B5G,UAA7B,IAA2CM,cAAc,CAACsG,KAAD,CAAd,CAAsB,CAAtB,MAA6B3G,SAA/E;AACD,OANoE,CAArE,EAMI;AACF,aAAK+E,uBAAL,GAA+B1E,cAA/B;;AACA,aAAKwG,mBAAL,CAAyBxG,cAAzB;AACD;AACF;AAhCA,GA/ByB,EAgEzB;AACD4B,IAAAA,GAAG,EAAE,qBADJ;AAED1C,IAAAA,KAAK,EAAE,SAASsH,mBAAT,CAA6BxG,cAA7B,EAA6C;AAClD,UAAIyG,MAAM,GAAG,IAAb,CADkD,CAGlD;;;AACA,UAAIC,aAAa,GAAG,KAAKtF,KAAL,CAAWsF,aAAX,IAA4B,KAAKtF,KAAL,CAAWgE,YAA3D;AAEApF,MAAAA,cAAc,CAAC2G,OAAf,CAAuB,UAAUC,KAAV,EAAiB;AACtC,YAAIC,KAAK,GAAGlE,aAAa,CAACiE,KAAD,EAAQ,CAAR,CAAzB;AAAA,YACIlH,UAAU,GAAGmH,KAAK,CAAC,CAAD,CADtB;AAAA,YAEIlH,SAAS,GAAGkH,KAAK,CAAC,CAAD,CAFrB;;AAIA,YAAIC,OAAO,GAAGJ,aAAa,CAAChH,UAAD,EAAaC,SAAb,CAA3B;;AACA,YAAImH,OAAO,IAAI,IAAf,EAAqB;AACnBA,UAAAA,OAAO,CAACC,IAAR,CAAa,YAAY;AACvB;AACA;AACA,gBAAIzH,cAAc,CAAC;AACjBE,cAAAA,sBAAsB,EAAEiH,MAAM,CAACjC,uBADd;AAEjB/E,cAAAA,qBAAqB,EAAEgH,MAAM,CAAChC,sBAFb;AAGjB/E,cAAAA,UAAU,EAAEA,UAHK;AAIjBC,cAAAA,SAAS,EAAEA;AAJM,aAAD,CAAlB,EAKI;AACF;AACA,kBAAI8G,MAAM,CAACjB,QAAP,IAAmB,IAAvB,EAA6B;AAC3B;AACD,eAJC,CAMF;AACA;;;AACA,kBAAI,OAAOiB,MAAM,CAACjB,QAAP,CAAgBwB,eAAvB,KAA2C,UAA/C,EAA2D;AACzDP,gBAAAA,MAAM,CAACjB,QAAP,CAAgBwB,eAAhB,CAAgCtH,UAAhC,EAA4C,IAA5C;AACD,eAFD,MAEO;AACL;AACA;AACA;AACA,oBAAI,OAAO+G,MAAM,CAACjB,QAAP,CAAgByB,kBAAvB,KAA8C,UAAlD,EAA8D;AAC5DR,kBAAAA,MAAM,CAACjB,QAAP,CAAgByB,kBAAhB,CAAmC,CAAC,CAApC;AACD;;AACDR,gBAAAA,MAAM,CAACjB,QAAP,CAAgB0B,WAAhB;AACD;AACF;AACF,WA5BD;AA6BD;AACF,OArCD;AAsCD;AA9CA,GAhEyB,CAAjB,CAAX;AAgHA,SAAOtD,cAAP;AACD,CAtJoB,CAsJnB5E,aAtJmB,CAArB;;AAwJA,eAAe4E,cAAf","sourcesContent":["import { PureComponent } from 'react';\n\nfunction isInteger(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n\nfunction isRangeVisible(_ref) {\n  var lastRenderedStartIndex = _ref.lastRenderedStartIndex,\n      lastRenderedStopIndex = _ref.lastRenderedStopIndex,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\nfunction scanForUnloadedRanges(_ref) {\n  var isItemLoaded = _ref.isItemLoaded,\n      itemCount = _ref.itemCount,\n      minimumBatchSize = _ref.minimumBatchSize,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  var unloadedRanges = [];\n\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n\n  for (var _index = startIndex; _index <= stopIndex; _index++) {\n    var loaded = isItemLoaded(_index);\n\n    if (!loaded) {\n      rangeStopIndex = _index;\n      if (rangeStartIndex === null) {\n        rangeStartIndex = _index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push([rangeStartIndex, rangeStopIndex]);\n\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), itemCount - 1);\n\n    for (var _index2 = rangeStopIndex + 1; _index2 <= potentialStopIndex; _index2++) {\n      if (!isItemLoaded(_index2)) {\n        rangeStopIndex = _index2;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push([rangeStartIndex, rangeStopIndex]);\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  if (unloadedRanges.length) {\n    var firstRange = unloadedRanges[0];\n\n    while (firstRange[1] - firstRange[0] + 1 < minimumBatchSize && firstRange[0] > 0) {\n      var _index3 = firstRange[0] - 1;\n\n      if (!isItemLoaded(_index3)) {\n        firstRange[0] = _index3;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar InfiniteLoader = function (_PureComponent) {\n  inherits(InfiniteLoader, _PureComponent);\n\n  function InfiniteLoader() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, InfiniteLoader);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = InfiniteLoader.__proto__ || Object.getPrototypeOf(InfiniteLoader)).call.apply(_ref, [this].concat(args))), _this), _this._lastRenderedStartIndex = -1, _this._lastRenderedStopIndex = -1, _this._memoizedUnloadedRanges = [], _this._onItemsRendered = function (_ref2) {\n      var visibleStartIndex = _ref2.visibleStartIndex,\n          visibleStopIndex = _ref2.visibleStopIndex;\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!isInteger(visibleStartIndex) || !isInteger(visibleStopIndex)) {\n          console.warn('Invalid onItemsRendered signature; please refer to InfiniteLoader documentation.');\n        }\n\n        if (typeof _this.props.loadMoreRows === 'function') {\n          console.warn('InfiniteLoader \"loadMoreRows\" prop has been renamed to \"loadMoreItems\".');\n        }\n      }\n\n      _this._lastRenderedStartIndex = visibleStartIndex;\n      _this._lastRenderedStopIndex = visibleStopIndex;\n\n      _this._ensureRowsLoaded(visibleStartIndex, visibleStopIndex);\n    }, _this._setRef = function (listRef) {\n      _this._listRef = listRef;\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(InfiniteLoader, [{\n    key: 'resetloadMoreItemsCache',\n    value: function resetloadMoreItemsCache() {\n      var autoReload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      this._memoizedUnloadedRanges = [];\n\n      if (autoReload) {\n        this._ensureRowsLoaded(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this._listRef == null) {\n          console.warn('Invalid list ref; please refer to InfiniteLoader documentation.');\n        }\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var children = this.props.children;\n\n\n      return children({\n        onItemsRendered: this._onItemsRendered,\n        ref: this._setRef\n      });\n    }\n  }, {\n    key: '_ensureRowsLoaded',\n    value: function _ensureRowsLoaded(startIndex, stopIndex) {\n      var _props = this.props,\n          isItemLoaded = _props.isItemLoaded,\n          itemCount = _props.itemCount,\n          _props$minimumBatchSi = _props.minimumBatchSize,\n          minimumBatchSize = _props$minimumBatchSi === undefined ? 10 : _props$minimumBatchSi,\n          _props$threshold = _props.threshold,\n          threshold = _props$threshold === undefined ? 15 : _props$threshold;\n\n\n      var unloadedRanges = scanForUnloadedRanges({\n        isItemLoaded: isItemLoaded,\n        itemCount: itemCount,\n        minimumBatchSize: minimumBatchSize,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(itemCount - 1, stopIndex + threshold)\n      });\n\n      // Avoid calling load-rows unless range has changed.\n      // This shouldn't be strictly necsesary, but is maybe nice to do.\n      if (this._memoizedUnloadedRanges.length !== unloadedRanges.length || this._memoizedUnloadedRanges.some(function (_ref3, index) {\n        var _ref4 = slicedToArray(_ref3, 2),\n            startIndex = _ref4[0],\n            stopIndex = _ref4[1];\n\n        return unloadedRanges[index][0] !== startIndex || unloadedRanges[index][1] !== stopIndex;\n      })) {\n        this._memoizedUnloadedRanges = unloadedRanges;\n        this._loadUnloadedRanges(unloadedRanges);\n      }\n    }\n  }, {\n    key: '_loadUnloadedRanges',\n    value: function _loadUnloadedRanges(unloadedRanges) {\n      var _this2 = this;\n\n      // loadMoreRows was renamed to loadMoreItems in v1.0.3; will be removed in v2.0\n      var loadMoreItems = this.props.loadMoreItems || this.props.loadMoreRows;\n\n      unloadedRanges.forEach(function (_ref5) {\n        var _ref6 = slicedToArray(_ref5, 2),\n            startIndex = _ref6[0],\n            stopIndex = _ref6[1];\n\n        var promise = loadMoreItems(startIndex, stopIndex);\n        if (promise != null) {\n          promise.then(function () {\n            // Refresh the visible rows if any of them have just been loaded.\n            // Otherwise they will remain in their unloaded visual state.\n            if (isRangeVisible({\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\n              startIndex: startIndex,\n              stopIndex: stopIndex\n            })) {\n              // Handle an unmount while promises are still in flight.\n              if (_this2._listRef == null) {\n                return;\n              }\n\n              // Resize cached row sizes for VariableSizeList,\n              // otherwise just re-render the list.\n              if (typeof _this2._listRef.resetAfterIndex === 'function') {\n                _this2._listRef.resetAfterIndex(startIndex, true);\n              } else {\n                // HACK reset temporarily cached item styles to force PureComponent to re-render.\n                // This is pretty gross, but I'm okay with it for now.\n                // Don't judge me.\n                if (typeof _this2._listRef._getItemStyleCache === 'function') {\n                  _this2._listRef._getItemStyleCache(-1);\n                }\n                _this2._listRef.forceUpdate();\n              }\n            }\n          });\n        }\n      });\n    }\n  }]);\n  return InfiniteLoader;\n}(PureComponent);\n\nexport default InfiniteLoader;\n"]},"metadata":{},"sourceType":"module"}